''' Test suite for Equation '''
import os
import sys
import copy
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
import unittest
from unittest.mock import patch
from Builder import Key
from Builder import Name as N
from Builder import Fraction as F
from Builder import Element as E
from Builder import Equation as Eq
from Builder import Zero as Z
from Builder import Chain
from Builder import Equivalence as Equiv


class test_equation(unittest.TestCase):
    #
    def make_basic_one(self):
        n1 = N.Name(1, 3, 4)
        n2 = N.Name(3, 1, 4)
        n3 = N.Name(1, 3, 4)
        n4 = N.Name(3, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(2, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        return Eq.Equation([e1, e2, e3, e4])
    def make_basic_two_no_overlap(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f1)
        e3 = E.Element(n3, f1)
        e4 = E.Element(n4, f1)
        return Eq.Equation([e1, e2, e3, e4])
    def make_basic_three_overlap(self):
        n1 = N.Name(1, 3, 4)
        n2 = N.Name(3, 1, 4)
        n3 = N.Name(1, 1, 4)
        n4 = N.Name(0, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f1)
        e3 = E.Element(n3, f1)
        e4 = E.Element(n4, f1)
        return Eq.Equation([e1, e2, e3, e4])
    def make_basic_singlet(self):
        n1 = N.Name(1, 3, 4)
        n2 = N.Name(3, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f1)
        return Eq.Equation([e1, e2])
    def test_equation_create(self):
        eq1 = self.make_basic_one()
        self.assertEqual(eq1.count(), 3, msg='Failed to create Equation')
        #        with self.assertRaises(SystemExit) as cm:
    def test_equation_create_nolist(self):
        with self.assertRaises(SystemExit) as cm:
            eq1 = Eq.Equation(N.Name(1, 3, 4))
        self.assertEqual(cm.exception.code, 70, msg='Failed to crash on nolist')
    def test_equation_create_emptylist(self):
        with self.assertRaises(SystemExit) as cm:
            eq1 = Eq.Equation([])
        self.assertEqual(cm.exception.code, 71, msg='Failed to crash on empty list')
    def test_equation_create_non_elementlist(self):
        n1 = N.Name(1, 3, 4)
        with self.assertRaises(SystemExit) as cm:
            eq1 = Eq.Equation([n1])
        self.assertEqual(cm.exception.code, 72, msg='Failed to crash on non-element list')
    def test_equation_create_badbase(self):
        n1 = N.Name(1, 3, 5)
        n2 = N.Name(3, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f1)
        with self.assertRaises(SystemExit) as cm:
            eq1 = Eq.Equation([e1, e2])
        self.assertEqual(cm.exception.code, 73, msg='Failed to spot different bases')
    #
    def test_equation_count(self):
        n1 = N.Name(1, 3, 4)
        n2 = N.Name(3, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        eq1 = Eq.Equation([e1, e2])
        self.assertEqual(eq1.count(), 2, msg='Failed to have 2 Elements')
    #
    def test_equation_equal(self):
        n1 = N.Name(1, 3, 4)
        n2 = N.Name(3, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        eq1 = Eq.Equation([e1, e2])
        n3 = N.Name(1, 3, 4)
        n4 = N.Name(3, 1, 4)
        f3 = F.Fraction(2, 5)
        f4 = F.Fraction(4, 5)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        eq2 = Eq.Equation([e4, e3])
        self.assertEqual(eq1, eq2, msg='Failed to find them equal')
    def test_equation_notequal(self):
        n1 = N.Name(1, 3, 4)
        n2 = N.Name(3, 2, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        eq1 = Eq.Equation([e1, e2])
        n3 = N.Name(1, 3, 4)
        n4 = N.Name(3, 1, 4)
        f3 = F.Fraction(2, 5)
        f4 = F.Fraction(4, 5)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        eq2 = Eq.Equation([e3, e4])
        self.assertNotEqual(eq1, eq2, msg='Failed: found them equal names differ')
    def test_equation_notequalfrac(self):
        n1 = N.Name(1, 3, 4)
        n2 = N.Name(3, 1, 4)
        f1 = F.Fraction(2, 3)
        f2 = F.Fraction(2, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        eq1 = Eq.Equation([e1, e2])
        n3 = N.Name(1, 3, 4)
        n4 = N.Name(3, 1, 4)
        f3 = F.Fraction(2, 5)
        f4 = F.Fraction(4, 5)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        eq2 = Eq.Equation([e3, e4])
        self.assertNotEqual(eq1, eq2, msg='Failed: found them equal fractions differ')
    def test_equation_notequal_onezero(self):
        n1 = N.Name(1, 3, 4)
        n2 = N.Name(3, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        eq1 = Eq.Equation([e1, e2])
        n3 = N.Name(1, 3, 4)
        n4 = N.Name(3, 1, 4)
        f3 = F.Fraction(2, 5)
        f4 = F.Fraction(4, 5)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        eq2 = Eq.Equation([e3, e4])
        eq1.scale(F.Fraction(0, 1))
        self.assertNotEqual(eq1, eq2, msg='Failed, fractions differ')
    def test_equation_equal_twozero(self):
        n1 = N.Name(1, 3, 4)
        n2 = N.Name(3, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        eq1 = Eq.Equation([e1, e2])
        n3 = N.Name(1, 3, 4)
        n4 = N.Name(3, 1, 4)
        f3 = F.Fraction(2, 5)
        f4 = F.Fraction(4, 5)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        eq2 = Eq.Equation([e3, e4])
        eq1.scale(F.Fraction(0, 1))
        eq2.scale(F.Fraction(0, 1))
        self.assertEqual(eq1, eq2, msg='Failed, both zero should be equal')
    def test_equation_equal_nonequation(self):
        n1 = N.Name(1, 3, 4)
        n2 = N.Name(3, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        eq1 = Eq.Equation([e1, e2])
        with self.assertRaises(SystemExit) as cm:
            bo = (eq1 == n1)
        self.assertEqual(cm.exception.code, 74, msg='Failed to spot not equal to Equation')
    #
    def test_equation_key(self):
        n1 = N.Name(1, 3, 4)
        n2 = N.Name(3, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        eq1 = Eq.Equation([e1, e2])
        key1 = eq1.key()
        key2 = Key.Key([n1, n2])
        self.assertEqual(key1, key2, msg='Key returned does not match')
    #
    def test_equation_scale(self):
        n1 = N.Name(1, 3, 4)
        n2 = N.Name(3, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        eq1 = Eq.Equation([e1, e2])
        f3 = F.Fraction(-2, 3)
        eq1.scale(F.Fraction(-2, 1))
        self.assertEqual(f3, eq1.elementlist[0].fraction, msg='Scale failed for first element')
    #
    def test_equation_scale_notfrac(self):
        n1 = N.Name(1, 3, 4)
        n2 = N.Name(3, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        eq1 = Eq.Equation([e1, e2])
        with self.assertRaises(SystemExit) as cm:
            eq1.scale(1/4)
        self.assertEqual(cm.exception.code, 76, msg='Failed to note bad scale arg')
    #
    def make_eq1(self):
        n1 = N.Name(1, 3, 4)
        n2 = N.Name(3, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        return Eq.Equation([e1, e2])
    def make_eq2c2(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        n33 = N.Name(2, 1, 4)
        n4 = N.Name(3, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f33 = F.Fraction(3, 3).multiply(F.Fraction(-1, 1))
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        e33 = E.Element(n33, f33)
        return Eq.Equation([e1, e2, e3, e4]), Eq.Equation([e2, e33])
    #
    #
    def test_equation_present_yes_name(self):
        eq1 = self.make_eq1()
        n1 = N.Name(1, 3, 4)
        self.assertTrue(eq1.present(n1), msg='Should have said the Name was present')
    def test_equation_present_yes_element(self):
        eq1 = self.make_eq1()
        n1 = N.Name(1, 3, 4)
        f1 = F.Fraction(1, 3)
        e1 = E.Element(n1, f1)
        self.assertTrue(eq1.present(e1), msg='Should have said the Element was present')
    def test_equation_present_no_name(self):
        eq1 = self.make_eq1()
        n1 = N.Name(1, 2, 4)
        self.assertFalse(eq1.present(n1), msg='Should have not said the Name was present')
    def test_equation_present_no_element(self):
        eq1 = self.make_eq1()
        n1 = N.Name(1, 2, 4)
        f1 = F.Fraction(1, 3)
        e1 = E.Element(n1, f1)
        self.assertFalse(eq1.present(e1), msg='Should have not said the Element was present')
    def test_equation_present_badarg(self):
        eq1 = self.make_eq1()
        with self.assertRaises(SystemExit) as cm:
            eq1.present('(1/3)')
        self.assertEqual(cm.exception.code, 75, msg='Failed to spot bad arg')
    def test_equation_present_chain_yes(self):
        n1 = N.Name(1, 3, 4)
        n2 = N.Name(3, 1, 4)
        n3 = N.Name(2, 3, 4)
        n4 = N.Name(3, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(2, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        eq1 = Eq.Equation([e1, e2, e3, e4])
        chyes = Chain.Chain([e1, E.Element(N.Name(2, 2, 4), F.Fraction(-1, 3))])
        self.assertTrue(eq1.present(chyes), msg='Should have found the first element in the chain')
    def test_equation_present_chain_no(self):
        n1 = N.Name(1, 3, 4)
        n2 = N.Name(3, 1, 4)
        n3 = N.Name(2, 3, 4)
        n4 = N.Name(3, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(2, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        eq1 = Eq.Equation([e2, e3, e4])
        chno = Chain.Chain([e1, E.Element(N.Name(2, 2, 4), F.Fraction(-1, 3))])
        self.assertFalse(eq1.present(chno), msg='Should not have found any element in the chain')
    #
    def test_equation_give_yes_name(self):
        eq1 = self.make_eq1()
        n1 = N.Name(1, 3, 4)
        f1 = F.Fraction(1, 3)
        e1 = E.Element(n1, f1)
        elf = eq1.giveElement(n1)
        self.assertEqual(e1, elf, msg='Should have found the first element')
    def test_equation_give_yes_element(self):
        eq1 = self.make_eq1()
        n1 = N.Name(1, 3, 4)
        f1 = F.Fraction(1, 9)   # Note that the Element is different!
        e1 = E.Element(n1, f1)
        elf = eq1.giveElement(e1)
        self.assertEqual(E.Element(n1,F.Fraction(1, 3)), elf, msg='Should have found the first element')
    def test_equation_give_no_name(self):
        eq1 = self.make_eq1()
        n1 = N.Name(1, 2, 4)
        self.assertIsNone(eq1.giveElement(n1), msg='Should have not said the Name was present')
    def test_equation_give_no_element(self):
        eq1 = self.make_eq1()
        n1 = N.Name(1, 2, 4)
        f1 = F.Fraction(1, 3)
        e1 = E.Element(n1, f1)
        self.assertIsNone(eq1.giveElement(e1), msg='Should have not said the Element was present')
    def test_equation_give_badarg(self):
        eq1 = self.make_eq1()
        with self.assertRaises(SystemExit) as cm:
            elf = eq1.giveElement('(1/3)')
        self.assertEqual(cm.exception.code, 75, msg='Failed to spot bad arg')
    #
    def test_equation_give_str(self):
        eq1 = self.make_eq1()
        self.assertEqual(str(eq1), '0={1_3}(1/3)+{3_1}(2/3)', msg='String does not match')
    def test_equation_give_str_zero(self):
        eq1 = self.make_eq1()
        eq1.scale(F.Fraction(0,2))
        self.assertEqual(str(eq1), ' 0 ', msg='Zero string does not match')
    def test_equation_give_str_1(self):
        n1 = N.Name(1, 3, 4)
        f1 = F.Fraction(1, 3)
        e1 = E.Element(n1, f1)
        eq2 = Eq.Equation([e1])
        self.assertEqual(str(eq2), '0={1_3}(1/3)', msg='Single string does not match')
    def test_equation_give_repr(self):
        eq1 = self.make_eq1()
        self.assertEqual(repr(eq1), '0={1_3}(1/3)+{3_1}(2/3)', msg='String does not match')
    #
    def test_equation_cleanup_nothing_todo(self):
        eq1 = self.make_eq1()
        eq1.cleanup()
        self.assertEqual(eq1.count(), 2, msg='No change expected!')
    def test_equation_cleanup_zeroclear(self):
        eq1 = self.make_eq1()
        eq1.elementlist[0].mutemultiply(F.Fraction(0, 1))
        eq1.cleanup()
        self.assertEqual(eq1.count(), 1, msg='Should be only 1 left ' + str(eq1))
    def test_equation_cleanup_zeroall(self):
        eq1 = self.make_eq1()
        eq1.elementlist[0].mutemultiply(F.Fraction(0, 1))
        eq1.elementlist[1].mutemultiply(F.Fraction(0, 1))
        eq1.cleanup()
        self.assertTrue(eq1.isZero(), msg='Should be nothing left ' + str(eq1))
    def test_equation_cleanup_nothing_4(self):
        eq2, eq3 = self.make_eq2c2()
        eq2.cleanup()
        self.assertEqual(eq2.count(), 4, msg='No change expected')
    def test_equation_cleanup_zero_num2(self):
        eq2, eq3 = self.make_eq2c2()
        eq2.elementlist[2].fraction.mutemultiply(F.Fraction(0, 1))
        eq2.cleanup()
        self.assertEqual(eq2.count(), 3, msg='No change expected')
    def test_equation_cleanup_iszeroa(self):
        eq1 = self.make_eq1()
        eq1.iszero = True  # monkey with guts
        eq1.cleanup()
        self.assertTrue(eq1.isZero(), msg='Should, by construction, never happen')
    #
    def test_equation_inchain_yes(self):
        eq2, eq3 = self.make_eq2c2()
        p = []
        for entry in eq2.elementlist:
            p.append(copy.deepcopy(entry))
        ch1 = Chain.Chain(p)
        self.assertTrue(eq2.inchain([ch1]), msg='Should have all the elements, why not? ' + str(ch1.Key()) + ' ' + str(eq2))
    def test_equation_inchain_no(self):
        eq2, eq3 = self.make_eq2c2()
        p = []
        x=0
        for entry in eq2.elementlist:
            x = x + 1
            if x == 1:
                continue
            p.append(copy.deepcopy(entry))
        ch1 = Chain.Chain(p)
        self.assertFalse(eq2.inchain([ch1]), msg='Should have all the elements, why not? ' + str(ch1.Key()) + ' ' + str(eq2))
    def test_equation_inchain_sanity_list(self):
        eq2, eq3 = self.make_eq2c2()
        with self.assertRaises(SystemExit) as cm:
            eq2.inchain('{1_4}')
        self.assertEqual(cm.exception.code, 77, msg='Equation:inchain wants *list* of Chain')
    def test_equation_inchain_sanity_listbad(self):
        eq2, eq3 = self.make_eq2c2()
        with self.assertRaises(SystemExit) as cm:
            eq2.inchain(['{1_4}'])
        self.assertEqual(cm.exception.code, 78, msg='Equation:inchain wants list of *Chain*')
    def test_equation_inchain_emptylist(self):
        eq2, eq3 = self.make_eq2c2()
        p = []
        for entry in eq2.elementlist:
            p.append(copy.deepcopy(entry))
        ch1 = Chain.Chain(p)
        # Do bad things to the Equation.
        eq2.elementlist.pop(3)
        eq2.elementlist.pop(2)
        eq2.elementlist.pop(1)
        eq2.elementlist.pop(0)
        self.assertTrue(eq2.inchain([ch1]), msg='Empty equation is true by default!!')
    def test_equation_cleanup_empty(self):
        eq2, eq3 = self.make_eq2c2()
        # Do bad things to the Equation.
        eq2.elementlist.pop(3)
        eq2.elementlist.pop(2)
        eq2.elementlist.pop(1)
        eq2.elementlist.pop(0)
        eq2.cleanup()
        self.assertTrue(eq2.isZero(), msg='Should trigger iszero!')
    def test_equation_cleanup_almostempty(self):
        eq2, eq3 = self.make_eq2c2()
        # Do bad things to the Equation.
        eq2.elementlist.pop(3)
        eq2.elementlist.pop(2)
        eq2.elementlist.pop(1)
        eq2.elementlist[0].fraction.mutemultiply(F.Fraction(0, 1))
        eq2.cleanup()
        self.assertTrue(eq2.isZero(), msg='Should also trigger iszero!')
    #
    # Need to get Chain working before I can test the rest of cleanup
    # Reason--the Equation creation
    def test_equation_cleanup_cancelation(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        n33 = N.Name(2, 1, 4)
        n4 = N.Name(3, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f33 = F.Fraction(3, 3).multiply(F.Fraction(-1, 1))
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        e33 = E.Element(n33, f33)
        eq1 = Eq.Equation([e1, e2, e3, e4])
        # OK, that should be safely created
        # NOW do bad things to it (Chain can be used for that later)
        eq1.elementlist[1] = copy.deepcopy(e33)
        eq1.cleanup()
        self.assertEqual(eq1.count(), 2, msg='Should have cancelled 2')
    def test_equation_cleanup_2cancelation(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        n33 = N.Name(2, 1, 4)
        n4 = N.Name(3, 1, 4)
        n44 = N.Name(3, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f33 = F.Fraction(3, 3).multiply(F.Fraction(-1, 1))
        f4 = F.Fraction(4, 3)
        f44 = F.Fraction(4, 3).multiply(F.Fraction(-1, 1))
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        e33 = E.Element(n33, f33)
        e44 = E.Element(n44, f44)
        eq1 = Eq.Equation([e1, e2, e3, e4])
        # OK, that should be safely created
        # NOW do bad things to it (Chain can be used for that later)
        eq1.elementlist[1] = copy.deepcopy(e33)
        eq1.elementlist[0] = copy.deepcopy(e44)
        eq1.cleanup()
        self.assertTrue(eq1.isZero(), msg='Everything should have cancelled')
    #
    #
    def test_equation_formalsolve_ok(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        nx = N.Name(0, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        ex = E.Element(nx, f3)
        eq1 = Eq.Equation([e1, e2, e3])
        equiv = eq1.formalSolve(ex)
        self.assertEqual(str(equiv), '{0_1}(1)={1_1}(-6/3)+{2_1}(-9/3)', msg='Should have created a good Equivalance')
    def test_equation_formalsolve_ok_name(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        nx = N.Name(0, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        ex = E.Element(nx, f3)
        eq1 = Eq.Equation([e1, e2, e3])
        equiv = eq1.formalSolve(nx)
        self.assertEqual(str(equiv), '{0_1}(1)={1_1}(-6/3)+{2_1}(-9/3)', msg='Should have created a good Equivalance')
    def test_equation_formalsolve_bad_arg(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        nx = N.Name(0, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        ex = E.Element(nx, f3)
        eq1 = Eq.Equation([e1, e2, e3])
        with self.assertRaises(SystemExit) as cm:
            equiv = eq1.formalSolve(f3)
        self.assertEqual(cm.exception.code, 79, msg='Equation:formalSolve wants Name/Element')
    def test_equation_formalsolve_wrong_name(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        nx = N.Name(0, 0, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        ex = E.Element(nx, f3)
        eq1 = Eq.Equation([e1, e2, e3])
        with self.assertRaises(SystemExit) as cm:
            equiv = eq1.formalSolve(ex)
        self.assertEqual(cm.exception.code, 170, msg='Equation:formalSolve wants Name/Element *in* the Equation')
    #
    def test_equation_reduce_zero(self):
        # Test the reduce function w/ zeros
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        nx = N.Name(0, 0, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        ex = E.Element(nx, f3)
        eq1 = Eq.Equation([e1, e2, e3])
        z = Z.Zero([n3, nx])
        eq1.reduce(z)
        self.assertEqual(eq1.count(), 2, msg='Got rid of one element, should be 2')
    def test_equation_reduce_chain_nooverlap(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        nx = N.Name(0, 0, 4)
        ny = N.Name(0, 2, 4)
        nz = N.Name(0, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        fz = F.Fraction(1, 3)
        fy = F.Fraction(2, 3)
        fx = F.Fraction(3, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        ex = E.Element(nx, fx)
        ey = E.Element(ny, fy)
        ez = E.Element(nz, fz)
        eq1 = Eq.Equation([e1, e2, e3])
        ch1 = Chain.Chain([ex, ey, ez])
        eq1.reduce(ch1)
        self.assertEqual(str(eq1), '0={0_1}(1/3)+{1_1}(2/3)+{2_1}(1)', msg='No overlap, so nothing should change')
    def test_equation_reduce_chain_overlap(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        nx = N.Name(0, 1, 4)
        ny = N.Name(0, 2, 4)
        nz = N.Name(0, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        fz = F.Fraction(1, 3)
        fy = F.Fraction(2, 3)
        fx = F.Fraction(3, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        ex = E.Element(nx, fx)
        ey = E.Element(ny, fy)
        ez = E.Element(nz, fz)
        eq1 = Eq.Equation([e1, e2, e3])
        ch1 = Chain.Chain([ex, ey, ez])
        eq1.reduce(ch1)
        self.assertEqual(str(eq1), '0={0_1}(81/243)+{1_1}(2/3)+{2_1}(1)', msg='One replacement, no zero')
    def test_equation_reduce_list_chain_overlap(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        nx = N.Name(0, 1, 4)
        ny = N.Name(0, 2, 4)
        nz = N.Name(0, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        fz = F.Fraction(1, 3)
        fy = F.Fraction(2, 3)
        fx = F.Fraction(3, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        ex = E.Element(nx, fx)
        ey = E.Element(ny, fy)
        ez = E.Element(nz, fz)
        e4 = E.Element(N.Name(1, 3, 4), F.Fraction(1, 2))
        e5 = E.Element(N.Name(3, 3, 4), F.Fraction(3, 2))
        e6 = E.Element(N.Name(2, 3, 4), F.Fraction(2, 2))
        eq1 = Eq.Equation([e1, e2, e3])
        ch1 = Chain.Chain([ex, ey, ez])
        ch2 = Chain.Chain([e4, e5, e6])
        eq1.reduce([ch1, ch2])
        self.assertEqual(str(eq1), '0={0_1}(81/243)+{1_1}(2/3)+{2_1}(1)', msg='One replacement, no zero')
    def test_equation_reduce_list_chain_badlist(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        nx = N.Name(0, 1, 4)
        ny = N.Name(0, 2, 4)
        nz = N.Name(0, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        fz = F.Fraction(1, 3)
        fy = F.Fraction(2, 3)
        fx = F.Fraction(3, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        ex = E.Element(nx, fx)
        ey = E.Element(ny, fy)
        ez = E.Element(nz, fz)
        e4 = E.Element(N.Name(1, 3, 4), F.Fraction(1, 2))
        e5 = E.Element(N.Name(3, 3, 4), F.Fraction(3, 2))
        e6 = E.Element(N.Name(2, 3, 4), F.Fraction(2, 2))
        eq1 = Eq.Equation([e1, e2, e3])
        ch1 = Chain.Chain([ex, ey, ez])
        ch2 = Chain.Chain([e4, e5, e6])
        with self.assertRaises(SystemExit) as cm:
            eq1.reduce([ch1, eq1])
        self.assertEqual(cm.exception.code, 172, msg='Equation:reduce wants list[*Chain*]')
    def test_equation_reduce_list_chain_badarg(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        nx = N.Name(0, 1, 4)
        ny = N.Name(0, 2, 4)
        nz = N.Name(0, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        fz = F.Fraction(1, 3)
        fy = F.Fraction(2, 3)
        fx = F.Fraction(3, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        ex = E.Element(nx, fx)
        ey = E.Element(ny, fy)
        ez = E.Element(nz, fz)
        e4 = E.Element(N.Name(1, 3, 4), F.Fraction(1, 2))
        e5 = E.Element(N.Name(3, 3, 4), F.Fraction(3, 2))
        e6 = E.Element(N.Name(2, 3, 4), F.Fraction(2, 2))
        eq1 = Eq.Equation([e1, e2, e3])
        ch1 = Chain.Chain([ex, ey, ez])
        ch2 = Chain.Chain([e4, e5, e6])
        with self.assertRaises(SystemExit) as cm:
            eq1.reduce(ex)
        self.assertEqual(cm.exception.code, 171, msg='Equation:reduce wants Zero or Chain or list[*Chain*]')
    #
    def test_equation_replace_ok(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        nx = N.Name(0, 1, 4)
        ny = N.Name(0, 2, 4)
        nz = N.Name(0, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        fz = F.Fraction(1, 3)
        fy = F.Fraction(2, 3)
        fx = F.Fraction(3, 3)
        e1 = E.Element(n1, f1)
        e11 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        ex = E.Element(nx, fx)
        ey = E.Element(ny, fy)
        ez = E.Element(nz, fz)
        e4 = E.Element(N.Name(1, 3, 4), F.Fraction(1, 2))
        e5 = E.Element(N.Name(3, 3, 4), F.Fraction(3, 2))
        e6 = E.Element(N.Name(2, 3, 4), F.Fraction(2, 2))
        eq1 = Eq.Equation([e1, e2, e3])
        eq2 = Eq.Equation([e11, e4, e5, e6])
        equ2 = Equiv.Equivalence(eq2, e11)
        eq1.replace(equ2)
        self.assertEqual(eq1.count(), 5, 'Should have replace 1 with 3, on top of the 2')
    def test_equation_replace_ok_canceling(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        nx = N.Name(0, 1, 4)
        ny = N.Name(0, 2, 4)
        nz = N.Name(0, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        fz = F.Fraction(1, 3)
        fy = F.Fraction(2, 3)
        fx = F.Fraction(3, 3)
        e1 = E.Element(n1, f1)
        e11 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e22 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e33 = E.Element(n3, f3)
        ex = E.Element(nx, fx)
        ey = E.Element(ny, fy)
        ez = E.Element(nz, fz)
        e4 = E.Element(N.Name(1, 3, 4), F.Fraction(1, 2))
        e5 = E.Element(N.Name(3, 3, 4), F.Fraction(3, 2))
        e6 = E.Element(N.Name(2, 3, 4), F.Fraction(2, 2))
        eq1 = Eq.Equation([e1, e2, e3])
        eq2 = Eq.Equation([e11, e22, e33])
        equ2 = Equiv.Equivalence(eq2, e11)
        eq1.replace(equ2)
        self.assertTrue(eq1.isZero(), msg='Equation:replace Everything should have cancelled')
    def test_equation_replace_badarg(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        nx = N.Name(0, 1, 4)
        ny = N.Name(0, 2, 4)
        nz = N.Name(0, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        fz = F.Fraction(1, 3)
        fy = F.Fraction(2, 3)
        fx = F.Fraction(3, 3)
        e1 = E.Element(n1, f1)
        e11 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e22 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e33 = E.Element(n3, f3)
        ex = E.Element(nx, fx)
        ey = E.Element(ny, fy)
        ez = E.Element(nz, fz)
        eq1 = Eq.Equation([e1, e2, e3])
        eq2 = Eq.Equation([e11, e22, e33])
        equ2 = Equiv.Equivalence(eq2, e11)
        with self.assertRaises(SystemExit) as cm:
            eq1.replace(eq2)
        self.assertEqual(cm.exception.code, 173, msg='Equation:replace wants an Equivalance')
    def test_equation_reduce_knowncase(self):
        f1 = F.Fraction(1, 1)
        f2 = F.Fraction(-1, 1)
        n15 = N.Name(1, 5, 6)
        n25 = N.Name(2, 5, 6)
        n51 = N.Name(5, 1, 6)
        n52 = N.Name(5, 2, 6)
        ela = E.Element(n51, f1)
        elb = E.Element(n52, f1)
        eq1 = Eq.Equation([ela, elb])
        el1 = E.Element(n15, f1)
        el2 = E.Element(n25, f2)
        el3 = E.Element(n51, f1)
        el4 = E.Element(n52, f2)
        ch = Chain.Chain([el1, el2, el3, el4])
        eq1.reduce(ch)
        self.assertEqual(str(eq1), ' 0 ', msg='Should have cancelled out since ela=-elb')
    #
    def test_equation_hash(self):
        f1 = F.Fraction(1, 1)
        f2 = F.Fraction(-1, 1)
        n15 = N.Name(1, 5, 6)
        n25 = N.Name(2, 5, 6)
        n51 = N.Name(5, 1, 6)
        n52 = N.Name(5, 2, 6)
        ela = E.Element(n51, f1)
        elb = E.Element(n52, f1)
        eq1 = Eq.Equation([ela, elb])
        self.assertEqual(str(hash(eq1)), '626537374345253090', msg='Hash is obscure')
    #
    def test_equation_contents(self):
        f1 = F.Fraction(1, 1)
        f2 = F.Fraction(-1, 1)
        n15 = N.Name(1, 5, 6)
        n25 = N.Name(2, 5, 6)
        n51 = N.Name(5, 1, 6)
        n52 = N.Name(5, 2, 6)
        ela = E.Element(n51, f1)
        elb = E.Element(n52, f1)
        eq1 = Eq.Equation([ela, elb])
        newlist = eq1.contents()
        self.assertEqual(newlist, [ela, elb], msg='Lists should be the same')
    #
    def test_equation_init_dupecancel(self):
        f1 = F.Fraction(1, 1)
        f2 = F.Fraction(-1, 1)
        n15 = N.Name(1, 5, 6)
        n25 = N.Name(2, 5, 6)
        n51 = N.Name(5, 1, 6)
        n52 = N.Name(5, 2, 6)
        ela = E.Element(n51, f1)
        elb = E.Element(n52, f1)
        elc = E.Element(n51, f1.multiply(F.Fraction(-1, 1)))
        eq1 = Eq.Equation([ela, elb, elc])
        self.assertEqual(eq1.count(), 1, msg='Should be only one element left')
