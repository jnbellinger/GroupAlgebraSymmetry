''' Test suite for Equivalence '''
import os
import sys
import copy
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
import unittest
from unittest.mock import patch
from Builder import Name as N
from Builder import Fraction as F
from Builder import Element as E
from Builder import Equation as Eq
from Builder import Equivalence
from Builder import Zero as Z

#    def __init__(self, other, singleton):
#    def isZero(self):
#    def isTargetZero(self):
#    def count(self):
#    def __eq__(self, other):
#    def cleanup(self):
#    def present(self, other):
#    def key(self):
#    def scale(self, scaler):
#    def __str__(self):
#    def __repr__(self):

class test_equivalence(unittest.TestCase):
    #
    def make_basic_one(self):
        n1 = N.Name(1, 3, 4)
        n2 = N.Name(3, 1, 4)
        n3 = N.Name(1, 3, 4)
        n4 = N.Name(3, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(2, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f1)
        e3 = E.Element(n3, f1)
        e4 = E.Element(n4, f1)
        return Eq.Equation([e1, e2, e3, e4])
    def make_basic_two_no_overlap(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f1)
        e3 = E.Element(n3, f1)
        e4 = E.Element(n4, f1)
        return Eq.Equation([e1, e2, e3, e4])
    def make_basic_three_overlap(self):
        n1 = N.Name(1, 3, 4)
        n2 = N.Name(3, 1, 4)
        n3 = N.Name(1, 1, 4)
        n4 = N.Name(0, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f1)
        e3 = E.Element(n3, f1)
        e4 = E.Element(n4, f1)
        return Eq.Equation([e1, e2, e3, e4])
    def make_basic_singlet(self):
        n1 = N.Name(1, 3, 4)
        n2 = N.Name(3, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f1)
        return Eq.Equation([e1, e2])
    def test_equivalence_create_name(self):
        eq1 = self.make_basic_one()
        nx = N.Name(3, 3, 4)
        eqv1 = Equivalence.Equivalence(eq1, nx)
        self.assertEqual(eqv1.count(), 2, msg='Failed to create Equivalence, using Name')
    def test_equivalence_create_element(self):
        eq1 = self.make_basic_one()
        nx = N.Name(3, 3, 4)
        fx = F.Fraction(3, 7)
        ex = E.Element(nx, fx)
        eqv1 = Equivalence.Equivalence(eq1, ex)
        self.assertEqual(eqv1.count(), 2, msg='Failed to create Equivalence, using Element')
    def test_equivalence_create_list(self):
        n1 = N.Name(1, 3, 4)
        n2 = N.Name(3, 1, 4)
        n3 = N.Name(1, 1, 4)
        n4 = N.Name(0, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f1)
        e3 = E.Element(n3, f1)
        e4 = E.Element(n4, f1)
        n5 = N.Name(0, 2, 4)
        f5 = F.Fraction(1, 4)
        e5 = E.Element(n5, f5)
        equiv1 = Equivalence.Equivalence([e1, e2, e3, e4], e4)
        self.assertEqual(equiv1.count(), 4, msg='Should have created this OK')
    def test_equivalence_sanity_notlist(self):
        n1 = N.Name(1, 3, 4)
        f1 = F.Fraction(1, 3)
        e1 = E.Element(n1, f1)
        with self.assertRaises(SystemExit) as cm:
            eqv1 = Equivalence.Equivalence(n1, e1)
        self.assertEqual(cm.exception.code, 96, msg='Should fail from not-a-list')
    def test_equivalence_sanity_emptylist(self):
        n1 = N.Name(1, 3, 4)
        f1 = F.Fraction(1, 3)
        e1 = E.Element(n1, f1)
        with self.assertRaises(SystemExit) as cm:
            eqv1 = Equivalence.Equivalence([], e1)
        self.assertEqual(cm.exception.code, 91, msg='List is empty')
    def test_equivalence_sanity_notelement(self):
        n1 = N.Name(1, 3, 4)
        n2 = N.Name(3, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f1)
        with self.assertRaises(SystemExit) as cm:
            eqv1 = Equivalence.Equivalence([e1,e2], f1)
        self.assertEqual(cm.exception.code, 90, msg='Singleton is not an Element')
    def test_equivalence_sanity_list_notelement(self):
        n1 = N.Name(1, 3, 4)
        n2 = N.Name(3, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f1)
        with self.assertRaises(SystemExit) as cm:
            eqv1 = Equivalence.Equivalence([n1,n2], e1)
        self.assertEqual(cm.exception.code, 92, msg='List is not a list of Element')
    def test_equivalence_sanity_list_not_overlap_singleton(self):
        n1 = N.Name(1, 3, 4)
        n2 = N.Name(3, 1, 4)
        n3 = N.Name(3, 2, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(2, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f1)
        e3 = E.Element(n3, f3)
        with self.assertRaises(SystemExit) as cm:
            eqv1 = Equivalence.Equivalence([e1,e2], e3)
        self.assertEqual(cm.exception.code, 93, msg='List does not overlap singleton')
    def test_equivalence_sanity_equation_bad_singleton(self):
        n1 = N.Name(1, 3, 4)
        n2 = N.Name(3, 1, 4)
        n3 = N.Name(3, 2, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(2, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f1)
        e3 = E.Element(n3, f3)
        with self.assertRaises(SystemExit) as cm:
            eqv1 = Equivalence.Equivalence(Eq.Equation([e1,e2]), f3)
        self.assertEqual(cm.exception.code, 94, msg='Equivalence uses Equation and Name or Element')
    def test_equivalence_sanity_equation_not_overlap_singleton(self):
        n1 = N.Name(1, 3, 4)
        n2 = N.Name(3, 1, 4)
        n3 = N.Name(3, 2, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(2, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f1)
        e3 = E.Element(n3, f3)
        with self.assertRaises(SystemExit) as cm:
            eqv1 = Equivalence.Equivalence(Eq.Equation([e1,e2]), e3)
        self.assertEqual(cm.exception.code, 95, msg='Equivalence Equation must overlap singleton')
    #
    def test_equivalence_iszero_not(self):
        eq1 = self.make_basic_two_no_overlap()
        n4 = N.Name(2, 3, 4)
        f4 = F.Fraction(4, 3)
        e4 = E.Element(n4, f4)
        eqv1 = Equivalence.Equivalence(eq1, e4)
        self.assertFalse(eqv1.isZero(), msg='Expected to be False, why True?')
    def test_equivalence_iszero_is(self):
        eq1 = self.make_basic_two_no_overlap()
        n4 = N.Name(2, 3, 4)
        f4 = F.Fraction(4, 3)
        e4 = E.Element(n4, f4)
        eqv1 = Equivalence.Equivalence(eq1, e4)
        # DO BAD THINGS TO THIS:
        eqv1.collection.pop(1)
        eqv1.collection.pop(0)
        eqv1.cleanup()
        self.assertTrue(eqv1.isZero(), msg='Expected to be True, why False?')
    def test_equivalence_targetzero_is(self):
        eq1 = self.make_basic_two_no_overlap()
        n4 = N.Name(2, 3, 4)
        f4 = F.Fraction(4, 3)
        e4 = E.Element(n4, f4)
        eqv1 = Equivalence.Equivalence(eq1, e4)
        eqv1.cleanup()
        self.assertFalse(eqv1.isTargetZero(), msg='Expected targetzero to be False, why True?')
    def test_equivalence_zerotarget(self):
        eq1 = self.make_basic_two_no_overlap()
        n4 = N.Name(2, 3, 4)
        f4 = F.Fraction(4, 3)
        e4 = E.Element(n4, f4)
        eqv1 = Equivalence.Equivalence(eq1, e4)
        # DO BAD THING TO THIS
        eqv1.target.fraction.mutemultiply(F.Fraction(0, 1))
        eqv1.cleanup()
        self.assertEqual(eqv1.count(), 1, msg='Target zeroed, should have new target and lower size')
    #
    def test_equivalence_present_true_target_element(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        eq1 = Eq.Equation([e1, e2, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        e44 = E.Element(n4, f1)
        self.assertTrue(eqv1.present(e44), msg='This should have been element present')
    def test_equivalence_present_true_target_name(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        eq1 = Eq.Equation([e1, e2, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        e44 = E.Element(n4, f1)
        self.assertTrue(eqv1.present(n4), msg='This should have been name present')
    def test_equivalence_present_true_collection_element(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        eq1 = Eq.Equation([e1, e2, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        e44 = E.Element(n2, f1)
        self.assertTrue(eqv1.present(e44), msg='This should have been element present in target')
    def test_equivalence_present_true_collection_name(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        e5 = E.Element(n2, f4)
        eq1 = Eq.Equation([e1, e2, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        self.assertTrue(eqv1.present(n2), msg='This should have been name present in collection')
    def test_equivalence_present_bad_arg(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        e5 = E.Element(n2, f4)
        eq1 = Eq.Equation([e1, e2, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        #
        with self.assertRaises(SystemExit) as cm:
            a = eqv1.present(f1)
        self.assertEqual(cm.exception.code, 75, msg='Equivalence has a bad argument to present')
    def test_equivalence_present_not_collection_element(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        n5 = N.Name(0, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        e5 = E.Element(n5, f4)
        eq1 = Eq.Equation([e1, e2, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        self.assertFalse(eqv1.present(e5), msg='This was not element present in target')
    def test_equivalence_present_not_collection_name(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        n5 = N.Name(0, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        e5 = E.Element(n2, f4)
        eq1 = Eq.Equation([e1, e2, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        self.assertFalse(eqv1.present(n5), msg='This was not name present in collection')
    #
    def test_equivalence_key(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        n5 = N.Name(0, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        e5 = E.Element(n2, f4)
        eq1 = Eq.Equation([e1, e2, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        key = eqv1.key()
        self.assertEqual(str(key),'{2_1}{2_2}{2_3}', msg='Equivalence key should be 3 peices')
    #
    def test_equivalence_eq_ok(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        n5 = N.Name(0, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        e5 = E.Element(n2, f4)
        eq1 = Eq.Equation([e1, e2, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        e11 = E.Element(n1, f1)
        e22 = E.Element(n2, f2)
        e33 = E.Element(n3, f3)
        e44 = E.Element(n4, f4)
        eq11 = Eq.Equation([e11, e22, e33])
        eqv11 = Equivalence.Equivalence(eq11, e44)
        self.assertEqual(eqv1, eqv11, msg='Should have been equal')
    def test_equivalence_eq_bad(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        n5 = N.Name(0, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        e5 = E.Element(n2, f4)
        eq1 = Eq.Equation([e1, e2, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        e11 = E.Element(n1, f1)
        e22 = E.Element(n2, f2)
        e33 = E.Element(n3, f3)
        e44 = E.Element(n4, f4)
        eq11 = Eq.Equation([e11, e22, e33])
        eqv11 = Equivalence.Equivalence(eq11, e44)
        with self.assertRaises(SystemExit) as cm:
            a = (eqv1 == eq11)
        self.assertEqual(cm.exception.code, 74, msg='Equivalence has a bad argument to ==')
    def test_equivalence_eq_different_target(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        n5 = N.Name(0, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        e5 = E.Element(n2, f4)
        eq1 = Eq.Equation([e1, e2, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        e11 = E.Element(n1, f1)
        e22 = E.Element(n2, f2)
        e33 = E.Element(n3, f3)
        e44 = E.Element(n4, f4)
        eq11 = Eq.Equation([e11, e22, e33])
        eqv11 = Equivalence.Equivalence(eq11, e33)
        self.assertNotEqual(eqv1, eqv11, msg='Should not have been equal')
    def test_equivalence_eq_different_collection(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        n5 = N.Name(0, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        e5 = E.Element(n2, f4)
        eq1 = Eq.Equation([e1, e2, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        nx = N.Name(2, 2, 4)
        fx = F.Fraction(1, 8)
        ex = E.Element(nx, fx)
        e11 = E.Element(n1, f1)
        e22 = E.Element(n2, f2)
        e33 = E.Element(n3, f3)
        e44 = E.Element(n4, f4)
        eq11 = Eq.Equation([e11, e22, ex])
        eqv11 = Equivalence.Equivalence(eq11, e44)
        self.assertNotEqual(eqv1, eqv11, msg='Should not have been equal')
    def test_equivalence_eq_different_collection_2(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        n5 = N.Name(0, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        e5 = E.Element(n2, f4)
        eq1 = Eq.Equation([e1, e2, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        nx = N.Name(2, 2, 4)
        fx = F.Fraction(1, 8)
        ex = E.Element(nx, fx)
        e11 = E.Element(n1, f1)
        e22 = E.Element(n2, f2)
        e33 = E.Element(n3, f3)
        e44 = E.Element(n4, f4)
        eq11 = Eq.Equation([e11, e22, e33, ex])
        eqv11 = Equivalence.Equivalence(eq11, e44)
        self.assertNotEqual(eqv1, eqv11, msg='Should not have been equal')
    def test_equivalence_eq_different_fraction(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        n5 = N.Name(0, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        e5 = E.Element(n2, f4)
        eq1 = Eq.Equation([e1, e2, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        e11 = E.Element(n1, f2)
        e22 = E.Element(n2, f2)
        e33 = E.Element(n3, f3)
        e44 = E.Element(n4, f4)
        eq11 = Eq.Equation([e11, e22, e33])
        eqv11 = Equivalence.Equivalence(eq11, e44)
        self.assertNotEqual(eqv1, eqv11, msg='Should not have been equal, differing fraction')
    def test_equivalence_eq_zeros(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        n5 = N.Name(0, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        e5 = E.Element(n2, f4)
        eq1 = Eq.Equation([e1, e2, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        e11 = E.Element(n1, f1)
        e22 = E.Element(n2, f2)
        e33 = E.Element(n3, f3)
        e44 = E.Element(n4, f4)
        eq11 = Eq.Equation([e11, e22, e33])
        eqv11 = Equivalence.Equivalence(eq11, e44)
        # DO BAD THINGS
        eqv1.iszero = True
        eqv11.iszero = True
        self.assertEqual(eqv1, eqv11, msg='0 should be equal to 0')
    def test_equivalence_cleanup_zero(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        n5 = N.Name(0, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        e5 = E.Element(n2, f4)
        eq1 = Eq.Equation([e1, e2, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        # DO BAD THINGS
        eqv1.iszero = True
        eqv1.collection[0].fraction.mutemultiply(F.Fraction(0, 1))
        eqv1.cleanup()
        self.assertEqual(eqv1.count(), 2, msg='should be 2, cleanup forced to be a no-op here')
    def test_equivalence_cleanup_trivial_zeroed(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        n5 = N.Name(0, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        e5 = E.Element(n2, f4)
        eq1 = Eq.Equation([e1, e2, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        # DO BAD THINGS
        eqv1.collection.clear()
        eqv1.collection.append(eqv1.target)
        eqv1.cleanup()
        self.assertTrue(eqv1.isZero(), msg='should be forced to be zero because trivial')
    def test_equivalence_cleanup_zeroed(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        n5 = N.Name(0, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        e5 = E.Element(n2, f4)
        eq1 = Eq.Equation([e1, e2, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        # DO BAD THINGS
        eqv1.collection[0].fraction.mutemultiply(F.Fraction(0, 1))
        eqv1.cleanup()
        self.assertEqual(eqv1.count(), 1, msg='should be 1, cleanup removes an entry')
    def test_equivalence_cleanup_zeroed_both(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        n5 = N.Name(0, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        e5 = E.Element(n2, f4)
        eq1 = Eq.Equation([e1, e2, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        # DO BAD THINGS
        eqv1.collection[0].fraction.mutemultiply(F.Fraction(0, 1))
        eqv1.cleanup()
        eqv1.collection[0].fraction.mutemultiply(F.Fraction(0, 1))
        eqv1.cleanup()
        self.assertTrue(eqv1.isZero(), msg='should be zero, no entries left')
    def test_equivalence_cleanup_zeroed_both_atonce(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        n5 = N.Name(0, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        e5 = E.Element(n2, f4)
        eq1 = Eq.Equation([e1, e2, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        # DO BAD THINGS
        eqv1.collection[1].fraction.mutemultiply(F.Fraction(0, 1))
        eqv1.collection[0].fraction.mutemultiply(F.Fraction(0, 1))
        eqv1.cleanup()
        self.assertTrue(eqv1.isZero(), msg='should be zero, no entries left, testing multiple')
    #
    def test_equivalence_create_ok_contents(self):
        # PUT IN A TEST FOR str(equiv) to make sure that the good creation is good.
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        e5 = E.Element(n2, f4)
        eq1 = Eq.Equation([e1, e2, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        self.assertEqual(str(eqv1), '{2_3}(1)={2_1}(-6/3)+{2_2}(-9/3)', msg='Creation gave wrong result')
    def test_equivalence_str_0(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        eq1 = Eq.Equation([e1, e2, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        # Do bad thing to this
        eqv1.iszero = True
        self.assertEqual(str(eqv1), ' 0 ', msg='str for zero gave wrong result')
    def test_equivalence_str_1(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        eq1 = Eq.Equation([e1, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        # Do bad thing to this
        self.assertEqual(str(eqv1), '{2_3}(1)={2_2}(-9/3)', msg='Creation gave wrong result')
    def test_equivalence_repr(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        eq1 = Eq.Equation([e1, e2, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        self.assertEqual(repr(eqv1), '{2_3}(1)={2_1}(-6/3)+{2_2}(-9/3)', msg='Creation gave wrong result')
    #
    def test_equivalence_scale(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        fx = F.Fraction(1, 3)
        eq1 = Eq.Equation([e1, e2, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        eqv1.scale(fx)
        self.assertEqual(str(eqv1), '{2_3}(1/3)={2_1}(-6/9)+{2_2}(-1)', msg='Scale gave wrong result')
    def test_equivalence_scale_byzero(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        fx = F.Fraction(0, 3)
        eq1 = Eq.Equation([e1, e2, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        eqv1.scale(fx)
        self.assertTrue(eqv1.isZero(), msg='Scale by 0 should make it 0')
    def test_equivalence_scale_bad(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        fx = F.Fraction(0, 3)
        eq1 = Eq.Equation([e1, e2, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        with self.assertRaises(SystemExit) as cm:
            eqv1.scale(n4)
        self.assertEqual(cm.exception.code, 76, msg='Scale should fail, not a fraction')
    #
    def test_equivalence_cleanup_duplicate_name(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        n5 = N.Name(2, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        ex = E.Element(n5, f4)
        fx = F.Fraction(0, 3)
        eq1 = Eq.Equation([e1, e2, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        # DO VERY BAD THING
        eqv1.collection[0]=copy.deepcopy(ex)
        eqv1.cleanup()
        self.assertEqual(str(eqv1), '{2_3}(1)={2_2}(27/3)', msg='Should only be 1 element left')
    def test_equivalence_cleanup_duplicate_name_incol(self):
        n1 = N.Name(2, 3, 4)
        n2 = N.Name(2, 1, 4)
        n3 = N.Name(2, 2, 4)
        n4 = N.Name(2, 3, 4)
        n5 = N.Name(2, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        f4 = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e4 = E.Element(n4, f4)
        ex = E.Element(n3, f4)
        fx = F.Fraction(0, 3)
        eq1 = Eq.Equation([e1, e2, e3])
        eqv1 = Equivalence.Equivalence(eq1, e4)
        # DO VERY BAD THING
        eqv1.collection[0]=copy.deepcopy(ex)
        eqv1.cleanup()
        self.assertEqual(str(eqv1), '{2_3}(1)={2_2}(-5/3)', msg='Should only be 1 element left')
    #
    def test_equivalence_replace_ok(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        nx = N.Name(0, 1, 4)
        ny = N.Name(0, 2, 4)
        nz = N.Name(0, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        fz = F.Fraction(1, 3)
        fy = F.Fraction(2, 3)
        fx = F.Fraction(3, 3)
        e1 = E.Element(n1, f1)
        e11 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        ex = E.Element(nx, fx)
        ey = E.Element(ny, fy)
        ez = E.Element(nz, fz)
        e4 = E.Element(N.Name(1, 3, 4), F.Fraction(1, 2))
        e5 = E.Element(N.Name(3, 3, 4), F.Fraction(3, 2))
        e6 = E.Element(N.Name(2, 3, 4), F.Fraction(2, 2))
        eq1 = Eq.Equation([e1, e2, e3, ez])
        eq2 = Eq.Equation([e11, e4, e5, e6])
        equ1 = Equivalence.Equivalence(eq1, ez)
        equ2 = Equivalence.Equivalence(eq2, e11)
        equ1.replace(equ2)
        self.assertEqual(str(equ1), '{0_3}(1)={1_1}(-6/3)+{2_1}(-9/3)+{1_3}(9/6)+{3_3}(27/6)+{2_3}(9/3)', msg='Should replace 1 w/ 3')
        #self.assertEqual(equ1.count(), 5, 'Should have replace 1 with 3, on top of the 2')
    def test_equivalence_replace_ok_nooverlap(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        nx = N.Name(3, 1, 4)
        ny = N.Name(0, 2, 4)
        nz = N.Name(0, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        fz = F.Fraction(1, 3)
        fy = F.Fraction(2, 3)
        fx = F.Fraction(3, 3)
        e1 = E.Element(n1, f1)
        e11 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        ex = E.Element(nx, fx)
        ey = E.Element(ny, fy)
        ez = E.Element(nz, fz)
        e4 = E.Element(N.Name(1, 3, 4), F.Fraction(1, 2))
        e5 = E.Element(N.Name(3, 3, 4), F.Fraction(3, 2))
        e6 = E.Element(N.Name(2, 3, 4), F.Fraction(2, 2))
        eq1 = Eq.Equation([e1, e2, e3, ez])
        eq2 = Eq.Equation([ex, e4, e5, e6])
        equ1 = Equivalence.Equivalence(eq1, ez)
        equ2 = Equivalence.Equivalence(eq2, ex)
        equ1.replace(equ2)
        self.assertEqual(str(equ1), '{0_3}(1)={0_1}(-1)+{1_1}(-6/3)+{2_1}(-9/3)', msg='Should not replace anything')
    def test_equivalence_replace_ok_canceling(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        nx = N.Name(0, 1, 4)
        ny = N.Name(0, 2, 4)
        nz = N.Name(0, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        fz = F.Fraction(1, 3)
        fy = F.Fraction(2, 3)
        fx = F.Fraction(3, 3)
        e1 = E.Element(n1, f1)
        e11 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e22 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e33 = E.Element(n3, f3)
        ex = E.Element(nx, fx)
        ey = E.Element(ny, fy)
        ez = E.Element(nz, fz)
        e4 = E.Element(N.Name(1, 3, 4), F.Fraction(1, 2))
        e5 = E.Element(N.Name(3, 3, 4), F.Fraction(3, 2))
        e6 = E.Element(N.Name(2, 3, 4), F.Fraction(2, 2))
        eq1 = Eq.Equation([e1, e2, e3])
        equ1 = Equivalence.Equivalence(eq1, e2)
        eq2 = Eq.Equation([e11, e22, e33])
        equ2 = Equivalence.Equivalence(eq2, e11)
        equ1.replace(equ2)
        self.assertTrue(equ1.isZero(), msg='Equivalence:replace Everything should have cancelled')
    def test_equivalence_replace_badarg(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        nx = N.Name(0, 1, 4)
        ny = N.Name(0, 2, 4)
        nz = N.Name(0, 3, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        fz = F.Fraction(1, 3)
        fy = F.Fraction(2, 3)
        fx = F.Fraction(3, 3)
        e1 = E.Element(n1, f1)
        e11 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e22 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e33 = E.Element(n3, f3)
        ex = E.Element(nx, fx)
        ey = E.Element(ny, fy)
        ez = E.Element(nz, fz)
        eq1 = Eq.Equation([e1, e2, e3])
        equ1 = Equivalence.Equivalence(eq1, e1)
        eq2 = Eq.Equation([e11, e22, e33])
        equ2 = Equivalence.Equivalence(eq2, e11)
        with self.assertRaises(SystemExit) as cm:
            equ1.replace(eq2)
        self.assertEqual(cm.exception.code, 77, msg='Equivalence:replace wants an Equivalance')
    #
    def test_equivalence_mutemultiply_ok(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        e1 = E.Element(n1, f1)
        e11 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e22 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        eq1 = Eq.Equation([e1, e2, e3])
        equ1 = Equivalence.Equivalence(eq1, e1)
        equ1.mutemultiply(F.Fraction(1, 2))
        self.assertEqual(str(equ1), '{0_1}(1/2)={1_1}(-1)+{2_1}(-9/6)', msg='Equivalence should have scaled')
    def test_equivalence_mutemultiply_notok(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        eq1 = Eq.Equation([e1, e2, e3])
        equ1 = Equivalence.Equivalence(eq1, e1)
        with self.assertRaises(SystemExit) as cm:
            equ1.mutemultiply(n1)
        self.assertEqual(cm.exception.code, 78, msg='Equivalence:mutemultiply wants a Fraction')
    def test_equivalence_mutemultiply_zero(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        eq1 = Eq.Equation([e1, e2, e3])
        equ1 = Equivalence.Equivalence(eq1, e1)
        equ1.mutemultiply(F.Fraction(0, 2))
        self.assertTrue(equ1.isZero(), msg='Equivalence.mutemultiply should be 0')
    #
    def test_equivalence_replace_dup(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        eq1 = Eq.Equation([e1, e2, e3])
        equ1 = Equivalence.Equivalence(eq1, e1)
        equ2 = equ1
        equ1.replace(equ2)
        self.assertEqual(str(equ1), '{0_1}(1)={1_1}(-6/3)+{2_1}(-9/3)', msg='Should have been unchanged')
    def test_equivalence_replace_target_same(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        nx = N.Name(3, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        fx = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        ex = E.Element(nx, fx)
        e11 = E.Element(n1, f1)
        e22 = E.Element(n2, f2)
        eq1 = Eq.Equation([e1, e2, e3])
        eq2 = Eq.Equation([e1, e2, ex])
        equ1 = Equivalence.Equivalence(eq1, e1)
        equ2 = Equivalence.Equivalence(eq2, e11)
        equ1.replace(equ2)
        self.assertEqual(str(equ1), '{0_1}(1)={1_1}(-6/3)+{2_1}(-9/6)+{3_1}(-6/3)', msg='Should be mixed')
    #
    def test_equivalence_subtract_ok(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        nx = N.Name(3, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        fx = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        ex = E.Element(nx, fx)
        e11 = E.Element(n1, f1)
        e22 = E.Element(n2, f2)
        eq1 = Eq.Equation([e1, e2, e3])
        eq2 = Eq.Equation([e1, e2, ex])
        equ1 = Equivalence.Equivalence(eq1, e1)
        equ2 = Equivalence.Equivalence(eq2, e11)
        eq3 = equ1.subtract(equ2)
        self.assertEqual(str(eq3), '0={2_1}(-9/3)+{3_1}(12/3)', msg='Should include both')
    def test_equivalence_subtract_badarg(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        nx = N.Name(3, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        fx = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        ex = E.Element(nx, fx)
        eq1 = Eq.Equation([e1, e2, e3])
        equ1 = Equivalence.Equivalence(eq1, e1)
        with self.assertRaises(SystemExit) as cm:
            equ1.subtract(n1)
        self.assertEqual(cm.exception.code, 79, msg='Equivalence:subtract wants an Equivalence')
    def test_equivalence_subtract_bad_targ(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        nx = N.Name(3, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        fx = F.Fraction(4, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        e11 = E.Element(n1, f1)
        e22 = E.Element(n2, f2)
        ex = E.Element(nx, fx)
        eq1 = Eq.Equation([e1, e2, e3])
        eq2 = Eq.Equation([e1, e2, ex])
        equ1 = Equivalence.Equivalence(eq1, e1)
        equ2 = Equivalence.Equivalence(eq2, ex)
        with self.assertRaises(SystemExit) as cm:
            equ1.subtract(equ2)
        self.assertEqual(cm.exception.code, 170, msg='Equivalence:subtract needs same target')
    def test_equivalence_equivalent_OK(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        eq1 = Eq.Equation([e1, e2, e3])
        equ1 = Equivalence.Equivalence(eq1, e1)
        equ2 = Equivalence.Equivalence(eq1, e2)
        self.assertTrue(equ1.equivalent(equ2), msg='These should be the same, just different targets')
    def test_equivalence_equivalent_badarg(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        eq1 = Eq.Equation([e1, e2, e3])
        equ1 = Equivalence.Equivalence(eq1, e1)
        equ2 = Equivalence.Equivalence(eq1, e2)
        with self.assertRaises(SystemExit) as cm:
            answer = equ1.equivalent(e2)
        self.assertEqual(cm.exception.code, 171, msg='Did it catch the bad argument?')
    #
    def test_equivalence_equivalent_notsame(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        nx = N.Name(3, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        ex = E.Element(nx, f3)
        eq1 = Eq.Equation([e1, e2, e3])
        eqx = Eq.Equation([e1, e2, ex])
        equ1 = Equivalence.Equivalence(eq1, e1)
        equ2 = Equivalence.Equivalence(eqx, e1)
        self.assertFalse(equ1.equivalent(equ2), msg='Supposed to be different!')
    def test_equivalence_equivalent_zero(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        nx = N.Name(3, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        ex = E.Element(nx, f3)
        eq1 = Eq.Equation([e1, e2, e3])
        eqx = Eq.Equation([e1, e2, ex])
        equ1 = Equivalence.Equivalence(eq1, e1)
        equ2 = Equivalence.Equivalence(eqx, e1)
        # DO BAD THINGS
        equ1.iszero = True
        equ2.iszero = True
        self.assertTrue(equ1.equivalent(equ2), msg='Supposed to be different!')
    #
    def test_equivalence_reverse(self):
        n1 = N.Name(0, 1, 4)
        n2 = N.Name(1, 1, 4)
        n3 = N.Name(2, 1, 4)
        f1 = F.Fraction(1, 3)
        f2 = F.Fraction(2, 3)
        f3 = F.Fraction(3, 3)
        e1 = E.Element(n1, f1)
        e2 = E.Element(n2, f2)
        e3 = E.Element(n3, f3)
        eq1 = Eq.Equation([e1, e2, e3])
        equ1 = Equivalence.Equivalence(eq1, e1)
        eq2 = equ1.reverseToEquation()
        self.assertEqual(eq1, eq2, msg='Supposed to be the same Equation')
